{"name":"Databob.kotlin","tagline":"Randomised, zero-boilerplate object builders","body":"# databob.kotlin\r\n\r\n[![coverage](https://coveralls.io/repos/daviddenton/databob.scala/badge.svg?branch=master)](https://coveralls.io/github/daviddenton/databob.kotlin?branch=master)\r\n[![kotlin](https://img.shields.io/badge/kotlin-1.0.0-blue.svg)](http://kotlinlang.org)\r\n[![build status](https://travis-ci.org/daviddenton/databob.kotlin.svg?branch=master)](https://travis-ci.org/daviddenton/databob.kotlin)\r\n[![bintray version](https://api.bintray.com/packages/daviddenton/maven/databob.kotlin/images/download.svg)](https://bintray.com/daviddenton/maven/databob.kotlin/_latestVersion)\r\n\r\n##### (Also available in [Scala](https://github.com/daviddenton/databob.scala) and [JavaScript](https://github.com/daviddenton/databob) flavours)\r\n\r\nDatabob provides a way to generate completely randomised object builders with zero-boilerplate code.\r\n\r\n###Why?\r\nThe problem of generating dummy test instances for our classes has been around for a long time. Given the following data classes...\r\n```kotlin\r\ndata class ReadReceipt(val read: Boolean)\r\n\r\ndata class EmailAddress(val value: String)\r\n\r\ndata class Email(val from: EmailAddress, val to: List<EmailAddress>, val date: ZonedDateTime, val read: Boolean, val subject: String, val readReceipt: Option<ReadReceipt>)\r\n\r\ndata class Inbox(val address: EmailAddress, val emails: List<Email>)\r\n```\r\n\r\nWe could start to write objects using the [TestBuilder](http://www.javacodegeeks.com/2013/06/builder-pattern-good-for-code-great-for-tests.html) pattern using the traditional method:\r\n```kotlin\r\nclass InboxBuilder {\r\n    private var address = EmailAddress(\"some@email.address.com\")\r\n    private var emails = listOf<Email>()\r\n\r\n    fun withAddress(newAddress: EmailAddress) = {\r\n        address = newAddress\r\n        this\r\n    }\r\n\r\n    fun withEmails(newEmails: List<Email>) = {\r\n        emails = newEmails\r\n        this\r\n    }\r\n\r\n    fun build() = Inbox(address, emails)\r\n}\r\n```\r\n\r\nKotlin makes this easier for us somewhat by leveraging data class ```copy()```. This also allows us to be compiler safe, as removing \r\na field will break the equivalent ```with``` method:\r\n```kotlin\r\nclass InboxBuilder {\r\n  private var inbox = Inbox(EmailAddress(\"some@email.address.com\"), List[Email]())\r\n  \r\n  def withAddress(newAddress: EmailAddress) = {\r\n    inbox = inbox.copy(address = newAddress)\r\n    this\r\n  }\r\n\r\n  def withEmails(newEmails: List[Email]) = {\r\n    inbox = inbox.copy(emails = newEmails)\r\n    this\r\n  }\r\n\r\n  def build = inbox\r\n}\r\n```\r\n\r\nTaking this even further with data class copy(), we can reduce this to:\r\n```kotlin\r\nclass BetterInboxBuilder private constructor(private val inbox: Inbox) {\r\n\r\n    constructor() : this(Inbox(EmailAddress(\"some@email.address.com\"), listOf<Email>()))\r\n\r\n    fun withAddress(newAddress: EmailAddress) = BetterInboxBuilder(inbox.copy(address = newAddress))\r\n\r\n    fun withEmails(newEmails: List<Email>) = BetterInboxBuilder(inbox.copy(emails = newEmails))\r\n\r\n    fun build() = inbox\r\n}\r\n```\r\n\r\nSo, better - but it still seems pretty tedious to maintain. Additionally, we don't really want tests to rely unknowingly on \r\nbits of default test data for multiple tests which will lead to an explosion of [ObjectMother](http://martinfowler.com/bliki/ObjectMother.html)-type methods with small variations \r\nto suit particular tests.\r\n\r\nWhat we really want are completely randomised instances, with important overrides set-up only for tests that rely on them. No sharing of test data across tests. Ever.\r\n\r\nEnter Databob. For a completely randomised instance, including non-primitive sub-tree objects:\r\n```kotlin\r\nDatabob().mk(Email::class)\r\n```\r\n\r\nThat's it. Want to override particular value(s)?\r\n```kotlin\r\nDatabob().mk(Email::class).copy(from = EmailAddress(\"my@real.email.com\"))\r\n```\r\n\r\nOr add your own rule for generating values?\r\n```kotlin\r\nval override = Generators.ofType { databob -> EmailAddress(databob.mk(String::class) + \"@\" + databob.mk(String::class) + \".com\") }\r\n\r\nDatabob(override).mk(Email::class)\r\n```\r\n\r\n### Out-of-the-box features:\r\n- Nested object-trees (ie. non-primitive fields)\r\n- All Kotlin/Java primitives\r\n- Kotlin and Java Collection classes\r\n- Java8 date-time values\r\n- Bindings for Funktionale monadic types (Option/Either)\r\n- Simple overriding mechanism for your own-types and custom generation rules\r\n\r\n### See it in action\r\nSee the [example code](https://github.com/daviddenton/databob.kotlin/tree/master/src/test/kotlin/examples).\r\n\r\n### Get it\r\n```XML\r\n<dependency>\r\n  <groupId>io.github.daviddenton</groupId>\r\n  <artifactId>databob.kotlin</artifactId>\r\n  <version>X.X.X</version>\r\n</dependency>\r\n```\r\n\r\nFor extension binding support (such as Funktionale, you'll need to also add relevant dependencies)\r\n\r\n###Contribute\r\nPRs gratefully accepted for other common types that might be useful.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}